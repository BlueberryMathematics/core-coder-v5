<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goop Field</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: black;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            min-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            transition: opacity 0.3s ease;
        }
        
        #controls.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .control-group input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .control-group input[type="range"] {
            margin-bottom: 5px;
        }
        
        .range-info {
            font-size: 11px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
        
        #toggleButton {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 11;
            background: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: black;
            transition: background-color 0.2s ease;
        }
        
        #toggleButton:hover {
            background: rgba(255, 255, 255, 0.9);
        }
        
        .color-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .color-control input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="toggleButton">Hide Settings</button>
        
        <div id="controls">
            <div class="control-group">
                <label>Noise Scale</label>
                <input type="range" id="noiseScale" min="0.1" max="200" step="0.1" value="3">
                <div class="range-info">
                    <span>0.1</span>
                    <span id="noiseScaleValue">3</span>
                    <span>200</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Noise Speed</label>
                <input type="range" id="noiseSpeed" min="0.01" max="2" step="0.01" value="0.2">
                <div class="range-info">
                    <span>0.01</span>
                    <span id="noiseSpeedValue">0.2</span>
                    <span>2</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Bump Strength</label>
                <input type="range" id="bumpStrength" min="0" max="3" step="0.01" value="0.2">
                <div class="range-info">
                    <span>0</span>
                    <span id="bumpStrengthValue">0.2</span>
                    <span>3</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Color Intensity</label>
                <input type="range" id="colorIntensity" min="0.5" max="3" step="0.1" value="1.5">
                <div class="range-info">
                    <span>0.5</span>
                    <span id="colorIntensityValue">1.5</span>
                    <span>3</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Specular Strength</label>
                <input type="range" id="specularStrength" min="0" max="3" step="0.01" value="1.0">
                <div class="range-info">
                    <span>0</span>
                    <span id="specularStrengthValue">1.0</span>
                    <span>3</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Shininess</label>
                <input type="range" id="shininess" min="1" max="128" step="1" value="32">
                <div class="range-info">
                    <span>1</span>
                    <span id="shininessValue">32</span>
                    <span>128</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Light Position X</label>
                <input type="range" id="lightX" min="-10" max="10" step="0.1" value="5">
                <div class="range-info">
                    <span>-10</span>
                    <span id="lightXValue">5</span>
                    <span>10</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Light Position Y</label>
                <input type="range" id="lightY" min="-10" max="10" step="0.1" value="5">
                <div class="range-info">
                    <span>-10</span>
                    <span id="lightYValue">5</span>
                    <span>10</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Light Position Z</label>
                <input type="range" id="lightZ" min="-10" max="10" step="0.1" value="5">
                <div class="range-info">
                    <span>-10</span>
                    <span id="lightZValue">5</span>
                    <span>10</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Color 1</label>
                <div class="color-control">
                    <input type="color" id="color1" value="#ff0000">
                    <span>Primary Color</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Color 2</label>
                <div class="color-control">
                    <input type="color" id="color2" value="#2e0000">
                    <span>Secondary Color</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Shader code
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform float uTime;
            uniform float uNoiseScale;
            uniform float uNoiseSpeed;
            uniform float uBumpStrength;
            uniform float uColorIntensity;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uLightPosition;
            uniform float uSpecularStrength;
            uniform float uShininess;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;

            // Simplex 2D noise
            vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                         -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod(i, 289.0);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                  dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            // Calculate normals from noise for consistent shadows
            vec3 calculateNormal(vec2 uv, float scale) {
                float eps = 0.005;
                float heightL = snoise((uv + vec2(-eps, 0.0)) * scale + uTime * uNoiseSpeed);
                float heightR = snoise((uv + vec2(eps, 0.0)) * scale + uTime * uNoiseSpeed);
                float heightD = snoise((uv + vec2(0.0, -eps)) * scale + uTime * uNoiseSpeed);
                float heightU = snoise((uv + vec2(0.0, eps)) * scale + uTime * uNoiseSpeed);
                vec3 normal = normalize(vec3(heightL - heightR, heightD - heightU, 2.0));
                return normal;
            }

            void main() {
                vec2 uv = vUv;
                float noise = snoise(uv * uNoiseScale + uTime * uNoiseSpeed);
                
                // Create bump effect tied to the noise
                float bump = noise * uBumpStrength;
                
                // Base gradient color
                vec3 baseColor = mix(uColor1, uColor2, uv.y);
                baseColor *= uColorIntensity;

                // Calculate consistent normal from noise for 3D effect
                vec3 normal = calculateNormal(uv, uNoiseScale);
                
                // Lighting calculations for cohesive shiny and shadowed surface
                vec3 lightDir = normalize(uLightPosition - vWorldPosition);
                float diff = max(dot(normal, lightDir), 0.0);

                // Specular highlights for glossy effect
                vec3 viewDir = normalize(-vWorldPosition);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess) * uSpecularStrength;
                
                // Combine diffuse and specular lighting on the gradient surface
                vec3 lighting = baseColor * (diff + 0.5) + vec3(1.0) * spec;

                // Apply the bump to create a 3D-like effect
                lighting += bump * 0.1;

                gl_FragColor = vec4(lighting, 1.0);
            }
        `;

        // Three.js setup
        let scene, camera, renderer, mesh, material, clock;
        let showSettings = true;

        // Uniform values
        const uniforms = {
            uTime: { value: 0 },
            uNoiseScale: { value: 3 },
            uNoiseSpeed: { value: 0.2 },
            uBumpStrength: { value: 0.2 },
            uColorIntensity: { value: 1.5 },
            uColor1: { value: new THREE.Color(0xff0000) },
            uColor2: { value: new THREE.Color(0x2e0000) },
            uLightPosition: { value: new THREE.Vector3(5, 5, 5) },
            uSpecularStrength: { value: 1.0 },
            uShininess: { value: 32.0 }
        };

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Clock for animation
            clock = new THREE.Clock();

            // Create material
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: uniforms
            });

            // Create mesh
            const geometry = new THREE.PlaneGeometry(1, 1, 128, 128);
            mesh = new THREE.Mesh(geometry, material);
            
            // Scale to fit viewport
            updateMeshScale();
            
            scene.add(mesh);

            // Setup controls
            setupControls();

            // Start animation loop
            animate();
        }

        function updateMeshScale() {
            const aspect = window.innerWidth / window.innerHeight;
            const fov = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(fov / 2) * camera.position.z;
            const width = height * aspect;
            
            mesh.scale.set(width, height, 1);
        }

        function setupControls() {
            const controls = document.getElementById('controls');
            const toggleButton = document.getElementById('toggleButton');

            // Toggle button functionality
            toggleButton.addEventListener('click', () => {
                showSettings = !showSettings;
                controls.classList.toggle('hidden', !showSettings);
                toggleButton.textContent = showSettings ? 'Hide Settings' : 'Show Settings';
            });

            // Setup range inputs
            const rangeInputs = [
                'noiseScale', 'noiseSpeed', 'bumpStrength', 'colorIntensity',
                'specularStrength', 'shininess', 'lightX', 'lightY', 'lightZ'
            ];

            rangeInputs.forEach(id => {
                const input = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                
                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueSpan.textContent = value;
                    
                    switch(id) {
                        case 'noiseScale':
                            uniforms.uNoiseScale.value = value;
                            break;
                        case 'noiseSpeed':
                            uniforms.uNoiseSpeed.value = value;
                            break;
                        case 'bumpStrength':
                            uniforms.uBumpStrength.value = value;
                            break;
                        case 'colorIntensity':
                            uniforms.uColorIntensity.value = value;
                            break;
                        case 'specularStrength':
                            uniforms.uSpecularStrength.value = value;
                            break;
                        case 'shininess':
                            uniforms.uShininess.value = value;
                            break;
                        case 'lightX':
                        case 'lightY':
                        case 'lightZ':
                            updateLightPosition();
                            break;
                    }
                });
            });

            // Setup color inputs
            document.getElementById('color1').addEventListener('input', (e) => {
                uniforms.uColor1.value = new THREE.Color(e.target.value);
            });

            document.getElementById('color2').addEventListener('input', (e) => {
                uniforms.uColor2.value = new THREE.Color(e.target.value);
            });
        }

        function updateLightPosition() {
            const x = parseFloat(document.getElementById('lightX').value);
            const y = parseFloat(document.getElementById('lightY').value);
            const z = parseFloat(document.getElementById('lightZ').value);
            uniforms.uLightPosition.value = new THREE.Vector3(x, y, z);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update time uniform
            uniforms.uTime.value = clock.getElapsedTime();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateMeshScale();
        }

        // Event listeners
        window.addEventListener('resize', onWindowResize);

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>